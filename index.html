<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Quebra Tijolinhos — Neon</title>
<style>
  :root{
    --bg1:#0a0f1f;
    --bg2:#0f1630;
    --accent:#7cffea;
    --accent2:#ff5af1;
    --accent3:#ffd166;
    --white:#e8f7ff;
  }
  html,body{
    height:100%; margin:0;
    background: radial-gradient(1200px 700px at 30% 20%, #0c1630, var(--bg1)) fixed;
    color:var(--white); font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  }
  .wrap{ display:flex; align-items:center; justify-content:center; height:100%; gap:24px; padding:20px; }
  .panel{
    width: 320px; max-width: 32ch; backdrop-filter: blur(12px);
    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
    border:1px solid rgba(124,255,234,0.25); border-radius:16px; padding:16px 18px;
    box-shadow: 0 12px 40px rgba(0,0,0,0.35);
  }
  .panel h1{ font-size: 1.35rem; margin:0 0 8px; color: var(--accent); }
  .panel p{ margin:8px 0 12px; color:#cfe9f7; }
  .ui-row{ display:flex; gap:10px; margin-top:10px; flex-wrap:wrap; }
  .btn{
    border:1px solid rgba(255,255,255,0.18); border-radius:12px;
    padding:10px 14px; background: linear-gradient(180deg, rgba(124,255,234,0.18), rgba(124,255,234,0.06));
    color:var(--white); cursor:pointer;
  }
  .btn.primary{ border-color: rgba(255,90,241,0.55); background: linear-gradient(180deg, rgba(255,90,241,0.28), rgba(255,90,241,0.1)); }
  .stat{ display:flex; justify-content:space-between; margin:6px 0; font-size:0.95rem; }
  canvas{
    width: 860px; height: 560px; max-width: 100%; aspect-ratio: 860/560;
    border-radius:16px; border:1px solid rgba(255,255,255,0.12);
    box-shadow: 0 18px 60px rgba(0,0,0,0.45), inset 0 0 40px rgba(124,255,234,0.12);
    background: radial-gradient(900px 600px at 70% 30%, rgba(255,90,241,0.08), rgba(124,255,234,0.06)), linear-gradient(180deg, var(--bg2), var(--bg1));
  }
  @media (max-width: 960px){
    .wrap{ flex-direction:column; }
    .panel{ order:2; width:100%; max-width:560px; }
    canvas{ order:1; width:100%; height:auto; }
  }
</style>
</head>
<body>
<div class="wrap">
  <canvas id="game" width="860" height="560" aria-label="Quebra tijolinhos"></canvas>
  <aside class="panel">
    <h1>Quebra Tijolinhos — Neon</h1>
    <p>Use o mouse ou setas para mover. Quebre os tijolos e avance de fase!</p>
    <div class="stat"><span>Pontuação</span><strong id="score">0</strong></div>
    <div class="stat"><span>Vidas</span><strong id="lives">3</strong></div>
    <div class="stat"><span>Fase</span><strong id="level">1</strong></div>
    <div class="ui-row">
      <button class="btn primary" id="startBtn">Iniciar</button>
      <button class="btn" id="pauseBtn">Pausar</button>
      <button class="btn" id="resetBtn">Reiniciar</button>
    </div>
  </aside>
</div>

<script>
(() => {
  // Canvas
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // UI
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const levelEl = document.getElementById('level');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');

  // Estado
  let running = false, paused = false;
  let level = 1, score = 0, lives = 3;

  // Raquete
  const paddle = { x: W/2, y: H - 36, w: 120, h: 16, speed: 3, targetX: W/2 };

  // Bola
  const balls = [];
  function newBall(x = W/2, y = H*0.6, speed = 3){
    const angle = (-Math.PI/3) + Math.random()* (Math.PI/6);
    balls.push({ x, y, r: 8, dx: Math.cos(angle)*speed, dy: Math.sin(angle)*speed });
  }

  // Tijolos
  let bricks = [];
  const BRICK_ROWS_BASE = 5, BRICK_COLS = 11, brickMargin = 10;
  const brickW = (W - (BRICK_COLS+1)*brickMargin) / BRICK_COLS, brickH = 22;

  function spawnLevel(n){
    bricks = [];
    const rows = BRICK_ROWS_BASE + Math.floor((n-1)/2);
    for(let r=0; r<rows; r++){
      for(let c=0; c<BRICK_COLS; c++){
        const x = brickMargin + c*(brickW+brickMargin);
        const y = 80 + r*(brickH+brickMargin);
        const hue = 180 + (r*20)%120;
        bricks.push({x,y,w:brickW,h:brickH,hp:1,alive:true, hue});
      }
    }
  }

  // Partículas
  const particles = [];
  function spawnBurst(x,y,hue,amount=28){
    for(let i=0;i<amount;i++){
      const speed = 2 + Math.random()*3;
      const ang = Math.random()*Math.PI*2;
      particles.push({
        x,y,
        dx: Math.cos(ang)*speed,
        dy: Math.sin(ang)*speed,
        life: 40 + Math.random()*20,
        hue
      });
    }
  }

  // Input
  const keys = {};
  window.addEventListener('keydown', e => { keys[e.key] = true; });
  window.addEventListener('keyup', e => { keys[e.key] = false; });
  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    paddle.targetX = e.clientX - rect.left;
  });

  // Utils
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function rectCircleCollide(rx,ry,rw,rh,cx,cy,cr){
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx-nx, dy=cy-ny;
    return (dx*dx + dy*dy) <= cr*cr;
  }

  // UI helpers
  function updateUI(){
    scoreEl.textContent = score;
    livesEl.textContent = lives;
    levelEl.textContent = level;
  }

  function resetGame(){
    score = 0; lives = 3; level = 1;
    balls.length = 0; particles.length = 0;
    paddle.w = 120; paddle.x = W/2; paddle.targetX = W/2;
    spawnLevel(level);
    newBall();
    updateUI();
  }

  // Botões
  startBtn.addEventListener('click', ()=>{
    if(!running){
      resetGame();
      running = true; paused = false;
      loop();
    }
  });
  pauseBtn.addEventListener('click', ()=>{ paused = !paused; });
  resetBtn.addEventListener('click', ()=>{
    resetGame();
    if(!running){ running = true; paused = false; loop(); }
  });

  // Desenho
  function drawBackground(){
    // leve vinheta
    const g = ctx.createRadialGradient(W*0.5,H*0.45,50, W*0.5,H*0.45, Math.max(W,H));
    g.addColorStop(0,'rgba(124,255,234,0.05)');
    g.addColorStop(1,'rgba(0,0,0,0.6)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // linhas sutis
    ctx.save();
    ctx.globalAlpha = 0.04;
    ctx.fillStyle = '#000';
    for(let y=0; y<H; y+=4){
      ctx.fillRect(0,y,W,1);
    }
    ctx.restore();
  }

  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function drawPaddle(){
    // suavização do movimento
    paddle.x += (paddle.targetX - paddle.x) * 0.12;
    if(keys['ArrowLeft']) paddle.targetX -= paddle.speed*2;
    if(keys['ArrowRight']) paddle.targetX += paddle.speed*2;
    paddle.x = clamp(paddle.x, paddle.w/2 + 8, W - paddle.w/2 - 8);

    const x = paddle.x - paddle.w/2, y = paddle.y;

    // brilho
    ctx.save();
    ctx.shadowColor = 'rgba(124,255,234,0.55)';
    ctx.shadowBlur = 16;
    const grad = ctx.createLinearGradient(x, y, x+paddle.w, y+paddle.h);
    grad.addColorStop(0,'#7cffea');
    grad.addColorStop(1,'#ff5af1');
    ctx.fillStyle = grad;
    roundRect(x,y,paddle.w,paddle.h,8);
    ctx.fill();
    ctx.restore();

    // linha de destaque
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.fillRect(x+6, y+3, paddle.w-12, 2);
  }

  function drawBalls(){
    balls.forEach(b=>{
      // rastro leve
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for(let i=0;i<6;i++){
        ctx.fillStyle = `rgba(255,90,241,${(0.18 - i*0.028)})`;
        ctx.beginPath(); ctx.arc(b.x - b.dx*i, b.y - b.dy*i, b.r - i*0.8, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();

      // bola
      ctx.save();
      ctx.shadowColor = 'rgba(255,90,241,0.6)';
      ctx.shadowBlur = 14;
      const grad = ctx.createRadialGradient(b.x,b.y,2, b.x,b.y,12);
      grad.addColorStop(0,'#fff');
      grad.addColorStop(1,'#ff5af1');
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
      ctx.restore();
    });
  }

  function drawBricks(){
    bricks.forEach(br=>{
      if(!br.alive) return;
      ctx.save();
      ctx.shadowColor = `hsla(${br.hue}, 80%, 60%, 0.6)`;
      ctx.shadowBlur = 16;
      const grad = ctx.createLinearGradient(br.x, br.y, br.x+br.w, br.y+br.h);
      grad.addColorStop(0, `hsl(${br.hue}, 80%, 60%)`);
      grad.addColorStop(1, 'rgba(255,255,255,0.25)');
      ctx.fillStyle = grad;
      roundRect(br.x, br.y, br.w, br.h, 6);
      ctx.fill();
      ctx.restore();

      // highlight
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.fillRect(br.x+5, br.y+3, br.w-10, 2);
    });
  }

  function drawParticles(){
    particles.forEach(p=>{
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = `hsla(${p.hue}, 90%, 60%, ${Math.max(0, p.life/60)})`;
      ctx.fillRect(p.x, p.y, 2.5, 2.5);
      ctx.restore();
    });
  }

  // Lógica
  function update(){
    // bolas
    balls.forEach(b=>{
      b.x += b.dx;
      b.y += b.dy;

      // paredes
      if(b.x - b.r < 0){ b.x = b.r; b.dx *= -1; }
      if(b.x + b.r > W){ b.x = W - b.r; b.dx *= -1; }
      if(b.y - b.r < 0){ b.y = b.r; b.dy *= -1; }

      // colisão com raquete
      if(rectCircleCollide(paddle.x - paddle.w/2, paddle.y, paddle.w, paddle.h, b.x, b.y, b.r)){
        b.y = paddle.y - b.r;
        const hit = (b.x - paddle.x) / (paddle.w/2); // -1 a 1
        const speed = Math.hypot(b.dx, b.dy);
        const angle = (-Math.PI/2) + hit * (Math.PI/3);
        b.dx = Math.cos(angle)*speed;
        b.dy = Math.sin(angle)*speed;
        // pequena explosão na batida
        spawnBurst(b.x, b.y, 180, 8);
      }

      // fundo — perdeu bola
      if(b.y - b.r > H){
        const idx = balls.indexOf(b);
        if(idx > -1) balls.splice(idx,1);
        if(balls.length === 0){
          lives--;
          if(lives <= 0){ gameOver(); }
          else { newBall(W/2, H*0.65, 3); }
          updateUI();
        }
      }
    });

    // colisões com tijolos
    balls.forEach(b=>{
      for(const br of bricks){
        if(!br.alive) continue;
        if(rectCircleCollide(br.x, br.y, br.w, br.h, b.x, b.y, b.r)){
          // reflexo simples
          const cx = br.x + br.w/2, cy = br.y + br.h/2;
          const nx = (b.x - cx) / br.w, ny = (b.y - cy) / br.h;
          if(Math.abs(nx) > Math.abs(ny)) b.dx *= -1; else b.dy *= -1;

          br.hp--;
          score += 10;
          if(br.hp <= 0){
            br.alive = false;
            score += 20;
            spawnBurst(b.x, b.y, br.hue, 26); // animação ao quebrar
          }
          updateUI();
          break; // evitar múltiplas colisões no mesmo frame
        }
      }
    });

    // partículas
    for(let i=particles.length-1; i>=0; i--){
      const p = particles[i];
      p.x += p.dx; p.y += p.dy;
      p.life -= 1.2;
      if(p.life <= 0) particles.splice(i,1);
    }

    // fase completa?
    if(bricks.length && bricks.every(br => !br.alive)){
      level++;
      spawnLevel(level);
      // levemente aumenta a velocidade da bola, mas mantém controlável
      balls.forEach(b=>{
        const s = Math.hypot(b.dx,b.dy);
        const factor = 1.06;
        b.dx = (b.dx/s) * s * factor;
        b.dy = (b.dy/s) * s * factor;
      });
      if(balls.length === 0) newBall(W/2, H*0.65, 3.2);
      updateUI();
    }
  }

  function gameOver(){
    running = false;
    // overlay
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#ff5af1';
    ctx.font = 'bold 42px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', W/2, H/2 - 10);
    ctx.fillStyle = '#7cffea';
    ctx.font = '20px system-ui';
    ctx.fillText('Clique em Reiniciar para jogar novamente', W/2, H/2 + 30);
    ctx.restore();
  }

  // Loop principal
  let last = 0;
  function loop(ts=0){
    if(!running) return;
    const dt = ts - last; last = ts;
    if(!paused){
      ctx.clearRect(0,0,W,H);
      drawBackground();
      update();
      drawBricks();
      drawBalls();
      drawPaddle();
      drawParticles();
    } else {
      // overlay de pausa
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#cfe9f7';
      ctx.font = 'bold 24px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('PAUSADO', W/2, H/2);
      ctx.restore();
    }
    requestAnimationFrame(loop);
  }

  // Splash inicial
  function splash(){
    ctx.clearRect(0,0,W,H);
    drawBackground();
    ctx.save();
    ctx.textAlign='center';
    ctx.fillStyle='#7cffea';
    ctx.font='bold 36px system-ui';
    ctx.fillText('Quebra Tijolinhos — Neon', W/2, H/2 - 40);
    ctx.fillStyle='#cfe9f7';
    ctx.font='18px system-ui';
    ctx.fillText('Clique em Iniciar para jogar', W/2, H/2);
    ctx.restore();
  }
  splash();
})();
</script>
</body>
</html>
